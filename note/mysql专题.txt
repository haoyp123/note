docker 安装mysql
    2059 - authentication plugin 'caching_sha2_password'的解决方法。
    这个是由于8以上版本得加密方式导致的。
    show variables like 'default_authentication_plugin'; 查看加密方式
    select host,user,plugin from mysql.user; 查看用户加密方式
    ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';
    把加密方式改为mysql_native_password 另外不仅要搞localhost的也要改%的

mysql 架构和内部模块
    client连接server server 用线程池进行处理的。
    8.0开始 mysql没有内置缓存了。

    一个select的执行流程
        连接到server
        查询缓存（8.0已经没有了）
        解析器---功能
        词法分析
           把sql拆分成单词，查看每个单词代表什么
        语法分析
            根据sql语法规则，判断你的sql是否正确。
        预处理器--功能
            select* from t1;
            进行语义分析。对sql进行进一步解析，保证sql语义正确。若t1表不存在报错，是此时做处理的。
        优化器--功能
            词法分析语法分析和预处理都正确的时候，优化器会对sql进行优化，选取一个它认为最优的执行路径。
            例如，多表关联查询先查询哪个表，如一个表有多个所引，具体使用哪个索引，另外对于一些恒等式1=1或者1<>1这种也会优化。
            判断规则：基于开销的优化器，服务端的开销。选择开销最小的执行路径。
            不是所有的sql都会进行优化，要注意sql写法。

        执行计划--功能
            把解析树进行执行。
            innodb 引擎———— 事务安全的，ACID特性，支持行级别锁定，有聚集索引。
            myisam 引擎———— 只有表级别锁，一般只用于读。
            EXPLAIN format=JSON SELECT * from user_innodb;
            存储引擎可以被修改，因为不同存储引擎提供的接口是一样的。
        执行器--功能
            执行器拿到执行计划，访问存储引擎，返回前端。

        数据过滤，计算是在server层，索引是在存储层。

    一个update/delete/insert的执行过程
        也需要查询加载存储引擎内存（不会只加载一点数据，会预加载，按页加载，innodb一页默认是16k，从磁盘加载到内存一次16k）
        从存储引擎内存返回到server内存（操作都是在server层实现）

        每次请求都读取磁盘的话 磁盘IO大，效率低，所以在存储引擎开辟了一块缓存区buffer pool（提升读写性能关键因素）
        读取或者更新都会先写入buffer pool 在写入磁盘。
        buffer pool 写入redo log 解决内存数据崩溃的问题。
        redo log 实现崩溃恢复
        innodb里边存储引擎中
        问题 为什么要先写入 buffer pool 在更新到磁盘呢？
        磁盘IO 分为两种 一种是随机IO ，一种是顺序IO，随机IO需要选址，所以慢，顺序IO不用选址，追加形式，在某些时候
        顺序IO速度甚至比内存快。
        undo log 事务日志
        增删改会记录到undo log 用于回滚。

        redo log是两段式提交为什么？

        bin log
        逻辑日志，记录的是操作语句。
        主从复制
        数据恢复

索引
    索引是数据库管理系统中的一个排序的数据结构。 使用索引避免全表扫描。
    索引存储的是 索引---数据对应的内存地址
    主键、唯一、全文、普通
索引 的存储结构

    演变
       二叉树---》  如果数据是排序好的，只有一个子树。
       平衡二叉树---》 左右子树的深度差不超过1，每个节点下最多只能有两个节点，树的深度过深。
       B树  特点是 N 和度(N+1) 两个两个键值 对应三个分叉。
       B+树 特点是 N 和度(N) 两个键值对应两个分叉。


    索引应该存储什么数据呢
        结构是树，节点是node，node应该存储什么信息？
        索引、数据在磁盘的地址、 左子节点和右子节点的引用。
        （B+树的情况下，内节点不存地址，地址都存放在叶子节点。叶子节点有个双向指针。
        只存储键值，节点存储数据更多，分叉更多。
        所以，基于索引拿到数据能力更强，不需要进行树的遍历，只需要便利指针即可。）

        innodb把数据加载到磁盘的最小单位是page，默认大小是16k，
        node节点的大小也设计是16k。node 16384个字节。
        一个节点只存储一个数据的话，不能完全利用node空间，而且每次加载需要占用大量IO。
        解决方式就是一个node 尽量多的存储数据。
        KEY的数量由什么决定呢？key的大小决定，尽量少用uuid 用些自增数列。
        用16384个字节/键值大小 +1 得到度数的。

        InnoDb
            索引文件.idb索引
            innodb只有两种索引:聚集索引和其他索引。
            聚集索引：索引的键值逻辑顺序于数据行的物理顺序是一致的。聚集索引的叶子存放的是完整数据。
            其他索引的叶子节点：主键索引。
            所以使用其他索引的时候会先检索自己的B+树，然后在检索主键的B+树。 这个过程叫做回表。


        主键索引是有序的 就按顺序插入，如果是无序的，会进行多次的数据合并和分裂。
        页不是一个页一个页申请的，是按64个页进行申请的，按区申请。进行调整比较少。

    行溢出问题
        一个page放不下，会把超出页大小的放到out-page中。

    索引一定会加快查找效率吗？
        否
        引入一个公式：离散度=（不重复的数据）/个数。
         比如10个数据，性别和手机号码 2/10=0.2  10/10 =1 性别的离散度是0.2 手机的离散度是10.
         在性别上建立索引不如全表扫描的快。

    联合索引的最左匹配原则。 必须以索引的第一个字段开始，不能跳过。必须使用最左边的索引
        比如联合索引 身份证号+考号。
        优先以字段顺序进行排序。

    覆盖索引 是索引的使用情况，查询的列是索引。

索引失效
    对索引进行表达式
    隐式转换
    like %
    负向查询<>


mysql的事务和锁
    什么是事务？ 事务是执行管理系统的一个逻辑单位，由一个有限的数据库操作序列构成。
    事务特性ACID 原子性 一致性 隔离性 持久性
    原子性：要么都成功要么都失败。
    一致性：事务提交前的状态和事务提交后的状态是一致的。
    隔离性：多个事务之间相互不影响。
    持久性：只要事务提交了对事务修改是永久的。








