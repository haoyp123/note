为什么要使用缓存
    减轻数据库压力。操作数据库是读写的IO操作，缓存是内存操作，比IO快。
    非关系型数据库，redis 、memcached 、mongodb等

redis和memcached的区别
    最重要的是redis支持持久化，另外，redis的数据类型比memcached多。

redis的应用场景
    缓存
    session共享解决方案
    分布式事务锁

redis 常用命令
    操作字符串
    set key value
    get key
    get keys

    type key 查看key的类型
    
    操作List集合
    lpush key value1 value2 value3
    lrange key start end
    
    操作hset

redis 单线程
    redis在执行命令的时候是单线程

redis 高级应用
    主从复制，读写分离 高可用
    主服务器写的时候数据要同步从服务器。
    哨兵机制：相当于心跳机制，主服务器挂了，选举一个服务器当主服务器，保证高可用。

redis 事务
    multi 开启事务
    命令。。
    exec 提交事务

redis 持久化
    持久化：将内存数据写入到硬盘。
    rdb 以数据的方式进行保存记录。
        redis的默认存储方式。redis宕机，之所以恢复后能继续查询（单节点）就是因为生成的了dump.rdb文件。
        配置文件中可以修改redis持久化的时间间隔。
        备份回复后重启才能生效。
    aof 以日志的形式进行保存备份。
        如set name jack  get 类型不会保存
    二者区别
    aof相对于安全，但是io操作比较多，消耗资源比较大。
    rdb是快照形式有一定的时间间隔，回复快，存储不够安全，如宕机情况下会丢失数据比较多。
    一般情况下， master服务采用aof（确保完整性），salve 采用rdb。

redis 数据失效
    缓存穿透：缓存穿透是指 通过key，redis没有缓存命中，直接请求到了数据库，相当于大量请求绕过了redis，给数据库造成压力，就是缓存穿透。
        布隆过滤或者缓存空对象
        布隆过滤：本质就是查询一个元素是否在集合中。
    缓存击穿：缓存击穿是指 一个非常热点的key，扛着大量请求，一旦缓存失效，大量并发直接访问数据。
    缓存雪崩：缓存层出现问题，导致请求直接访问数据库。
        高可用，redis集群。数据预热。限流，缓存失效后，通过队列或加锁控制访问数量，如semaphore。

redis 过期策略和内存淘汰机制
    过期策略
        定期删除+惰性删除
        定期删除是指对于设置过期时间的key，redis默认每隔100ms进行随机检查，过期删除。但是过期的key不一定立即删除。
        惰性删除是指查询key的时候，对于设置过期时间的，redis会检查是否过时了，过了就删除key。
   通过过期策略，可能有大量的过期key且没有被查询，会导致大量内存被占用，因此，redis还有内存淘汰机制。
    内存淘汰机制
        最近最少使用原则
        挑选将要过期的key进行淘汰
        随机淘汰
        拒绝淘汰写入数据报错

redis 数据一致性问题
    先更新数据库，在更新缓存。ab线程同时操作，a set id=1， b set id=2，b先写入了缓存， a后写入缓存，导致数据不一致，产生脏数据。

    先删除缓存，在更新数据库。ab线程同时操作，id =1 ，a set id=2，
    a删除了缓存，在更新数据库完成前，b查询缓存，无数据，b查询数据，更新缓存。产生脏数据。
    
    延迟双删策略 先删除缓存，在更新数据库，一定延迟后（如1秒），在删除缓存。会删除产生的脏数据。
    如果是第二次删除失败，仍旧会产生脏数据。ab线程同时操作，id =1 ，a set id=2，a删除了缓存，
    在更新数据库完成前，b查询缓存，无数据，b查询数据，更新缓存。a删除缓存失败。产生脏数据。
    
    延迟双删，需要一个补偿机制，解决删除失败的问题。
    
    更新数据库，数据库会写日志binlog日志，提取binlog日志记录的更新信息，删除缓存，删除失败，将信息写入队列，
    继续删除。
    参考：https://www.cnblogs.com/kexinxin/p/11745669.html

redis分布式锁
    //todo
