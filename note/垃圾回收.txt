jvm结构
堆 栈 方法区 程序计数器 本地方法栈

java对于垃圾的判断
    1.引用计数法
        给对象添加一个引用计数器，有引用的时候+1，失去引用的时候-1，当归为0时，表明对象不再被使用，则判断为垃圾。
        实现简单，效率快，缺点是无法解决循环引用的问题。
    2.可达性分析法
        通过一系列的"GC Roots"作为起点进行搜索，如果在"GC Roots"和对象之间没有一个引用链，

        说明该对象是不可达的，则说明对象没有被使用。
        GC  Roots ：栈中引用的对象、静态属性引用对象、常量引用对象和本地方法栈的对象。

        没有被引用的对象也不是非死不可，会经过两次的标记筛选。
        第一次筛选
        筛选条件是此对象是否需要执行finalize()方法。
        当对象没有覆盖finalize方法，或者虚拟机已经执行过finalize方法，虚拟机会将两种情况都视为没有必要被执行，对象被回收。
       第二次筛选
       如果对象被标记为有必要执行finalize方法，则虚拟机会将对象放在F-Queue中，finalizer线程执行。
       finalize方法是最后一次机会，若要在finalize中拯救自己，需要重新被引用。

java垃圾回收算法
    复制算法
        分为两块区域，一块用完后，将存活的对象移动到另外一块区域，然后将之前的内存空间一次性清理掉。
        缺点：造成空间浪费。
    标记清除法
        将需要回收的对象先标记出来，然后统计进行清楚。
        这样，会造内存空间不连续，产生大量空间碎片，如果新的对象内存不足，可能需要进行二次垃圾回收。

    标记整理算法
        标记出所有需要回收对象，将不需要清除的对象移动到另一端，然后直接清理掉边界以外的垃圾。

