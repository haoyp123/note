jvm结构
堆 栈 方法区 程序计数器 本地方法栈
堆栈 简单介绍
    堆可以理解为存储空间，栈是运行时空间。
    堆存放对象，栈存放基本数据类型和对象的引用。
    栈中的每个元素成为栈帧，执行一个方法会将方法压入栈帧。
    帧里面存放方法参数，局部变量和临时数据。
java对于垃圾的判断
    1.引用计数法
        给对象添加一个引用计数器，有引用的时候+1，失去引用的时候-1，当归为0时，表明对象不再被使用，则判断为垃圾。
        实现简单，效率快，缺点是无法解决循环引用的问题。
    2.可达性分析法
        通过一系列的"GC Roots"作为起点进行搜索，如果在"GC Roots"和对象之间没有一个引用链，

        说明该对象是不可达的，则说明对象没有被使用。
        GC  Roots ：栈中引用的对象、静态属性引用对象、常量引用对象和本地方法栈的对象。

        没有被引用的对象也不是非死不可，会经过两次的标记筛选。
        第一次筛选
        筛选条件是此对象是否需要执行finalize()方法。
        当对象没有覆盖finalize方法，或者虚拟机已经执行过finalize方法，虚拟机会将两种情况都视为没有必要被执行，对象被回收。
       第二次筛选
       如果对象被标记为有必要执行finalize方法，则虚拟机会将对象放在F-Queue中，finalizer线程执行。
       finalize方法是最后一次机会，若要在finalize中拯救自己，需要重新被引用。

java垃圾回收算法
    复制算法
        分为两块区域，一块用完后，将存活的对象移动到另外一块区域，然后将之前的内存空间一次性清理掉。
        缺点：造成空间浪费。
    标记清除法
        将需要回收的对象先标记出来，然后统计进行清楚。
        这样，会造内存空间不连续，产生大量空间碎片，如果新的对象内存不足，可能需要进行二次垃圾回收。

    标记整理算法
        标记出所有需要回收对象，将不需要清除的对象移动到另一端，然后直接清理掉边界以外的垃圾。

jvm 堆分代
    新生代
        分为三部分，eden survival0 survival1区 8:1:1
        当伊甸区和survival0满了以后，会进行一次清除，将eden和survival0中的垃圾清除，其他的对象移动到另外一块存活区。
        进行一次垃圾回收后，存活对象年龄+1，到一定年代后，进入老年代。

    老年代
        老年代的算法是标记清清除法，触发时间是老年代空间不足或者方法区空间不足的时候。
    元空间
        方法存在元空间，不与堆相连，在直接内存中，逻辑上可以认为在堆内存。


java类加载
    加载
    验证
    准备
    解析
    初始化
