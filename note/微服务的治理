发展历史
    架构：单体架构--》一个war包部署到tomcat
    问题：用户量增加--》服务器性能出现瓶颈，主要是问题是提高并行处理能力

    集群：用户--》nginx -->tomcat集群  （同一个war包，部署在不同的机器）
    问题：业务复杂度增加，维护困难

    --》垂直拆分,拆分为不同模块，用户 客户 产品 等

    --》粒度更细致。
    SOA 关注的是复用性。会有ESB协议

    SOA和微服务的区别？
        SOA 关注重用。微服务关注解耦，降低业务耦合度，更细粒度的模块。
        微服务更多的使用的是restful
        devops运维一体化。
        微服务是服务化思想的实践方法。

微服务的开发
    spring cloud（eureka feign ribbon hystrix ）
    spring cloud 是围绕springboot的做的。
    需要解决的问题。
        1.负载均衡
        2.服务的治理（注册发现）
        3.服务的稳定的（限流和熔断）
        4.服务的链路追踪

网关
    可以做前置后置的处理，黑白名单、限流、灰度、鉴权。
eureka
    做服务的注册发现。服务化以后需要对维护调用地址，毕竟麻烦，出现了eureka，将服务注册到eureka上，直接取就可以。

ribbon 做负载均衡。

hystrix 熔断 限流

configuration配置中心

spring cloud stream

zipkin/sleuth


微服务如何解决事务？




spring boot
简化了开发，约定优于配置
    1.maven结构
    2.spring-boot-start-web 内置tomcat、template
@SpringBootApplication注解
    @configuration
        基于注解的方式对bean的管理 表示的是这个类是配置类

    @EnableAutoConfiguration
        @AutoConfigurationPackage
        @Import(AutoConfigurationImportSelector.class)--对其他配置信息的导入

        AutoConfigurationImportSelector
        AutoConfigurationPackages.Registrar
        动态加载
        importSelector
        importBeanDefinitionRegister
        实现importSelector接口可以导入bean 也可以通过注解模式通过注解实现
        @Retention(RetentionPolicy.RUNTIME)
        @Import(CacheSelector.class)
        public @interface CacheInterface {
        }
        这样使用@cacheInterface注解就可以使用了


    springboot的自动加载
        AutoConfigurationMetaData路径：
        META-INF/spring-autoconfigure-metadata.properties
        SPI技术：扩展点。resource/META-INFO/spring.factories

        spring-autoconfigure-metadata.properties 这个文件是元数据
        com.study.config.StudyConfiguration.ConditionalOnClass=com.study.webdemo.configuration.TestClass
        只有有这个条件的时候才加载


    @ComponentScan
        扫包，交由容器托管