线程的基础知识

1.进程和线程的区别
	进程相当于一个应用程序，是所有线程的集合，每个线程是一条执行路径。


2.为什么要用多线程
	提高程序执行效率。
	cpu通过快速切换线程执行，并不是真正意义上的同时进行，
	电脑本身单位时间内执行效率并没有提高，为什么会提高执行效率。提高硬件--->多核

3.线程的创建方式
	继承Thread类、实现runnable接口、匿名内部类。

4.线程常用API
	sleep方法：使线程从运行状态到休眠状态，到时后，继续进入运行状态，不会使用线程死掉，也不会释放锁。
	getId：获取线程ID，cpu分配不会重复。
	getName：获取线程名称。
	线程中的异常，只能被捕获不能被抛出。
	run方法没有throw exception进行约束
	JVM的这种设计源自于这样一种理念：“线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。”

5.多线程的状态
	创建 就绪 运行 阻塞  死亡
	
6.多线程分批处理数据
	线程开的和cpu核数有关系。
	假设一个线程最多跑2万个数据。10万个数据需要5个线程。
	定义处理数据的类，可以使用构造函数，利用构造函数传递数据。
	

	
多线程之间的通信

1.线程安全
	当多个线程共同操作同一个全局变量的时候，有可能造成数据冲突，出现线程安全问题。
2.同步方法是 this锁

3.静态方法上的synchrozined 锁是类锁，当前类的class文件

4.死锁
	线程之间相互持有对方的锁。
	
	
	
多线程通讯
	1.wait 和 notify
	2.lock锁
		synchronized---不能手动开锁和解锁
		lock锁需要手动释放，此时，可能出现的问题：释放锁之前的代码如果抛异常，会造成死锁。
		解决方式：try catch finally 把释放锁写在finally中。
	3.lock和synchronized的区别
		lock 是接口 常用的是重入锁reentrantLock 和condition 一起使用
	4.condition 
		condition 是绑定在lock上的，可以为多个线程建立不同的condition，
		synchrionized只能实现一个线程阻塞，condition可以实现多个线程阻塞
		
	5.线程的中断
		interrupt 对于处于阻塞状态的线程，使用interrupt会抛出异常。
	6.join方法
		让一个线程先执行完在执行另外一个线程，线程启动后join，然后再启动另外一个线程。
		
	
Java内存模型
	1.特性
	线程三大特性：原子性、有序性和可见性。
	可见性:一个线程修改数据之后，其他线程能够立即看到修改后的值。
	有序性:按照顺序执行。
	2.java内存结构
		指的是堆栈方法区
	  java内存模型
		jmm就是内存模型，定义了线程和主内存之间的抽象关系。
		线程之前的共享变量存在主内存中。
		每个线程有一个本地内存，本地内存操作共享数据副本，然后刷新主线程。
		之所以出现线程安全问题，是因为其他线程不能及时看到修改的数据。
	3.volatile 关键字
		每次都从主内存中读取值。
		另外，同步方法，同步代码块结束后，会刷新主内存。
		synchronized 不仅保证可见性还保证原子性。
	4.threadlocal
		使用前先初始化
		使共享变量私有，每个线程使用自己的变量
		原理是：threadlocal底层维护了一个threadlocalmap
	5.线程池
		通过线程池管理线程，因为启动或者停止一个线程非常缓慢。利用线程池可以减少内存消耗。
		企业在使用线程池的时候会spring整合。
		java通过executors提供创建4种创建线程池的方式。
		缓存线程池、固定大小的线程池、支持定时任务的线程池、单例线程池。
			
-------
Java中线程的使用
    Runnable 接口
    Thread类
    Callable/future
        callable 接口提供了call方法，
        futureTask 实现了runnable接口和future接口，实现了get方法获取线程返回消息。
        thread 传个futureTask就可以并发执行。适配器设计模式。
    threadPool
    一般应用场景：跑批、对账。

线程的几种状态
 创建

 就绪
     等待  wait
 运行

 阻塞      synchronized

 销毁
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
