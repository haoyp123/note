设计模式最重要的作用是什么？
    设计模式的由来、如何使用设计模式

   设计原则：
    开闭 对修改关闭，对扩展开发
    里氏替换 子类实现父类的抽象方法，不能覆盖父类的非抽象方法。
    单一职责
    迪米特法则
    依赖倒置
    接口隔离

工厂设计模式
    简单工厂
        工厂对象决定创建哪个产品的实例。把创建产品的过程封装起来，对于客户端而言不可见。
        简单工厂，可能会有很多if else，逻辑可能比较复杂。创建逻辑前很多校验等，后续修改等不好解决。
        calender.getInstance();
        客户端只需要传入一个工厂类的参数，简单工厂把多个参数的职责放在一个类中，不易扩展多个，如果扩展产品的时候需要添加多个工厂。

    工厂方法模式。
        定义一个创建产品的接口，让实现这个接口的类决定创建哪个工厂。工厂方法让类的实例化推迟到子类实现。
        与简单工厂相比，工厂方法模式抽象出来了一个工厂接口， 工厂接口只定义了方法，具体由子类实现。
        单一职责、开闭原则。一个类只干一件事情，后续新增产品只需要新增工厂和实现即可，不用修改已有代码。


    抽象工厂
        是指创建一切相关或者相互依赖对象的接口，无需指定他们的具体实现类。
        产品族和产品等级结构。产品等级结构是：同一个产品。产品族是：不同产品。
        抽象工厂解决的是一个产品下有多个产品族或者一个产品族下有多个产品的问题。
        缺点：新增产品后，需要修改大量代码。层次结构复杂，不易理解。
        优点：定义了生产所有产品的接口，从而使客户端不依赖于具体实现。


单例和原型模式
    单例：确保一个类在任何情况下只有一个实例。
    饿汉式：不管用不用的上，先创建了再说。类创建的时候加载。
        缺点：浪费内存空间。

    懒汉式：太懒了，使用的时候才初始化。

    静态内部类：不使用时候不创建，使用的时候才创建，才加载内部类，所以线程安全，
    但是可以使用反射机制破坏单例。也可以使用反序列化破坏单例，用readResolve解决序列化的问题。

    枚举：从jdk层面为枚举单例保驾护航了。
    如何保证单例？
    序列化如何破坏单例?

原型模式
    原型模式创建对象不是通过new 是通过字节码创建对象的。
    类初始化复杂、构造函数复杂、循环中产生大量对象。

    浅克隆：只克隆地址。
    深克隆：克隆数据。

代理设计模式
    目的就是对目标对象的增强和保护。
    静态代理和动态代理
    静态代理：显示声明被代理对象  service 也是相当于一个静态代理。
    动态代理：
    动态代理反编译的类。
    动态的继承了 proxy类实现了接口方法。
    public final class $Proxy0 extends Proxy implements Person
    super.h.invoke()
    h是invocationHandler接口的子类，也就是代理类的invoke方法。

    jdk生成代理的时候是生成一个类实现接口。
    cglib是asm框架，自己写字节码，每次生成类。
    jdk 是反射机制，每次都是通过反射调用。cglib是生成复杂，生成所有逻辑的class方法调用高。
    cglib有个问题，对于final方法无法进行调用。

委派模式和策略模式
    委派模式负责任务的调度和分配，代理模式注重的是过程，委派模式注重的是结果。
    多任务统筹分配。



